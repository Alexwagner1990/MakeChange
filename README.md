## MAKE Change Project

### Skill Distillery Week 1 Homework

#### How To Run This Project
Run the MakeChangeAppFinal.java app file to start the program - the MakeChangeApp.java file does not have a main method. Enter in dollar amounts when prompted by the program. Entering invalid values will close the program, so further use of the app after entering an invalid set of values requires running the program again.

#### Project Description

This program is the interface used in the American Freedom Emporium Capitalism Superstore automated stores to process customer purchases. The customer enters the cost of an item and a payment amount, both in dollars. more than two decimal values can be entered for the cost of an item or for a payment, but only the first two decimal values will be considered. If the user enters a negative cost value or payment; value, an error message is returned and the program ends. 

The dollar amounts entered are converted to pennies. If the user enters a cost value greater than the payment value, a different error message displays and the program ends. If the user enters a cost value equal to the payment value, then no change is returned - the transaction ends and the program closes. If the user enters a payment value greater that the cost value, then change is returned. A number of bills and coins equal to the difference between the payment and the cash are returned. The greatest denominations are printed first, so the fewest number of bills and coins required to provide exact change are returned. After the user receives change the program closes. 


###Lessons Learned

Trying to use doubles to round numbers to a specific place (in this case the hundredths place) proved to be very difficult. The first version of this program tried to preserve the double values given by the user and convert them to integers each time the program needed to print out a dollar value or return change. Typically an important decimal would be rounded off, and the change value would occasionally be off by a penny or so. I first tried to fix the problem by adding a penny to the final total if the remaining amount of change was less than 0.01 but greater than 0, but this ended up resolving some cost/cash combinations but breaking others. For instance, an entry of "21.123" could end up actually equaling 21.12300000001 or 12.122999999, and there was no consistent way for me to deduce how the double would end up being stored for a particular value. Once I figured out that it made more sense to just convert the users entered amounts to pennies and use the new values throughout the program, the rounding issues appeared to be resolved.

This project also really drove home for me the importance of methods. I approached the problem essentially by running the values entered by the user through a lot of if statements, and this approach would have been basically unjustifiable if I put every if statement into the main method. However, splitting the if statements up into several methods made the development process much smoother. I basically started from the top of what was required for the program to run as intended, and when I came up with the step I just created a method for the step (e.g. "The first thing this program needs is a way for the user to input a cost. I'll make a method called costOfItem(); and put what I need to execute that step in there). This made it very easy for me to track the flow of my program and make ordering changes as necessary (e.g. I first made the program to check if the user paid exact change before checking if the user paid enough money - I realized my mistake and since both processes were in separate methods it was very easy to rearrange them in an order that made sense). Methods made it easier for me to follow and modify the flow of the program.

Since my program ran lots of if statements, using methods made it easier to reuse those if statements with slightly different bodies. I basically only needed to write one method to output the number of twenty dollar bills received, and once that method was working I could just copy that method for each other monetary denomination and update some number values accordingly. If the main method had just contained several if statements with no methods, then it would have been much more fragile and cumbersome to duplicate the same process over and over again. I realize this also could have been done in a loop, but I found copy/pasting the methods more straightforward than constructing a loop.

Methods also made it easy for me to recover from disasterous mistakes. The first version of the program that preserved doubles eventually became too difficult to tinker on the edges with, and I made the decision to write a whole new program. Since I had broken the program down into methods, though, I could simply create the old project as a new object in the new project and use the methods from the old project that actually worked with minor modifications. Starting over from scratch meant that I would have likely written ~200 more lines of code than I had to.

Jake also gave me a good tip about utilizing System.out.print to find out exactly where in the program things were going wrong - that's definitely something I will utilize in the future. I got pretty deep into the rabbit hole of trying to fix what I thought the program was doing vs what it actually was doing - having the program print out exactly what it was doing helped me accurately diagnose what was wrong with the program.

I thought that turning my failed project into an object to be used by my new project would be a good opportunity for me to practice using objects, but I recognize that it would probably have been easier to just copy the methods I liked into the final project class and discard the failed class. Eclipse seems to agree - there are suggestions to "access the static methods in a static way" whenever I use the object. This doesn't seem to affect how the program runs on the user end and the program still compiles as expected, so since I still don't really understand what makes a method static or not I chose to just leave well enough alone for now (well, I know adding "static" to its signature makes a method static, but I don't have enough experience or understanding to know when a method should be static vs when it should not be). I will definitely follow-up with Steve or Rob or Denise on Monday when they have time and ask them about these Eclipse suggestions.
